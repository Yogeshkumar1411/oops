C++

	Programing paradigm
	object oreiented paradiagm-> properties of object
	
	
car - entity
	manufacturer
	color
	price
	max speed
	
	-->these are attribues and charecteristic of car


	drive
  	accelerate
	open the door
	fuel indicaion
	
	--> behaviour of car

like car we can think student or book etc..


class is a building block of oop. user defined data types.

int, char, float, double -> pre-defined data types
array, pointer, func -> derived data types\
struct, unnion, enum, typrdef,class -> user defined data type 

if want to store charecteristic and behaviour of the user.

The class doesn't have any data. The represents a blue print. If you want to create a object the class will act as a model for that object.

Employee:

#include<iostream>
//using std::string;
using namespace std;

class Employee
{
//attributes//Everyone will have

//Everything inside class in c++ is private by default. Here access modifiers come into picture.
//private, public, protected
//private-> whatever is private those not going to be accessible outside of the class
//public-> will be to access the members outside of the class
//protected-> somewhere in between public and private. rules->comes under inheritence.


public:
	string Name;
	string Company;
	int Age;

//behaviour//wrt to one person
	void introducionYOurself(){
		
		cout<<"Name - "<< Name << endl;
		cout<<"Company - "<< Company << endl;
		cout<<"Age - "<< Age << endl;
	}

};


int main()
{
	Employee employee1;// class variable
	employee1.Name = "Saldina";
	employee1.Company = "YT-CodeBeauty";
	employee1.Age = 25;

	employee1.inroductionYourself();
	


}
//if want to create another employee, obsviously we will go like this "Employee employe2"
	
	Employee employee2;
	employee1.Name = "Saldina";
	employee1.Company = "YT-CodeBeauty";
	employee1.Age = 25;

	employee1.inroductionYourself();


 if we want to create 10 more employees we will follow the above steps which is not efficient

now constructor will comes into picture --> constructor is a special type of method that is invoked each time that an object an object of a class created.

default constructor -> previous also we had constructor that is default constructor-> it is term to describe the constructor automaically genereated by the compiler

 1. constructor is like other method (member functions), but constructor doesn't have any return type.
 2. Constructor has the same name as the class that it belongs to 
 3. constructor need to be public


//constructor//

when we decided to create the our own constructor then we will loss default constructor that automatically generated by the compiler.

class Employee{

public:
	....;
	....;
	....;
	Employee(string name, string company, int age){		
		Name = name;
		Company = company;
		Age = age;
	}
};

int main()
{
	Employee employee1 = Employee("Saldina", "YT-CodeBeauty",25);
	employee1.introductionYourself();
	Employee employee2 = Employee("John", "Amazon", 35);	
	employee2.introductionYourself();
}


4 pillars of oops
	1. Encapsulation
	2. Absraction
	3. Inheritence
	4. Polymorphism


Encapsulation:
	The idea of encapsulation is idea is budling or tying together data and methods that operate on that data so that they are grouped together within a class.

why do we need this?
	We do this with the purpose od preventing anyone or anything outside of our class to be able to directly accesss the data and to interact with it and modify it.

this is not really mean that other class invoking our data-->

	we don't want that other class to able to directly modify and change and interact with my data. Because we want to provide our own way for that to happen. By giving very specific public functions we can acheive that the other class can invoke and in that way interact with my data.


how do you access encapsulated properties of a class?

	Through its methods (member functions). And these methods are very often implemented as setters and getters.


class Employee
{
private://encapsulating
	string Name;
	string company;
	int Age;
public:
	void setName(string name){
		Name = name;
	}
	string getName(){
		return Name;
	}	
	void setCompany(string company){
		Company = company;
	}
	string getCompany(){
		return Company;
	}
	void setAge(int age){
		Age = age;
	}
	int getAge(){
		return Age;
	}

//the above methods are public anyone outside the can access these methods,whereas properties (Name, Company, Age) are encapsulated means they are private or they are hidden within this class and no one else besides members of this class here(same class) are goig to be able to access them directly.
	
};

int main()
{
	Employee employee1;
	employee1.setAge(39);
	employee1.setName("John");
	cout<<employee1.getName()<<" is "<<employee1.getAge()<<" years old"<<endl;
}

o/p=> John is 39 years old

The basic idea of the encapsulation is to make the properties of the object as a private; and if we want to access those properties outside of that class we should acheive through the methods of the same class (e.g., setters and getters as above).


//Abstraction//
 Abstraction means hiding complex things behind a procedure that makes those things look simple. e.g., smart phone -> camera-> we just pressing buttion click-> but in back side there is lot of procedures to take pictures. Means all of the complexity hiding from the user.
